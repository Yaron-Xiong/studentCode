package com.yaronxiong.algorithms.leetcode.l0;

import java.util.Arrays;

/**
 * 924. 尽量减少恶意软件的传播
 * 算术评级: 7
 * 第 106 场周赛
 * Q4
 * 1869
 * 相关标签
 * 相关企业
 * 给出了一个由 n 个节点组成的网络，用 n × n 个邻接矩阵图graph表示。在节点网络中，当 graph[i][j] = 1时，表示节点i能够直接连接到另一个节点 j。
 * <p>
 * 一些节点initial最初被恶意软件感染。只要两个节点直接连接，且其中至少一个节点受到恶意软件的感染，那么两个节点都将被恶意软件感染。这种恶意软件的传播将继续，直到没有更多的节点可以被这种方式感染。
 * <p>
 * 假设 M(initial) 是在恶意软件停止传播之后，整个网络中感染恶意软件的最终节点数。
 * <p>
 * 如果从initial中移除某一节点能够最小化 M(initial)， 返回该节点。如果有多个节点满足条件，就返回索引最小的节点。
 * <p>
 * 请注意，如果某个节点已从受感染节点的列表 initial 中删除，它以后仍有可能因恶意软件传播而受到感染。
 * <p>
 * 示例 1：
 * <p>
 * 输入：graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
 * 输出：0
 * 示例 2：
 * <p>
 * 输入：graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]
 * 输出：0
 * 示例 3：
 * <p>
 * 输入：graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2]
 * 输出：1
 * <p>
 * 提示：
 * <p>
 * n == graph.length
 * n == graph[i].length
 * 2 <= n <= 300
 * graph[i][j]==0或1.
 * graph[i][j] == graph[j][i]
 * graph[i][i] == 1
 * 1 <= initial.length <= n
 * 0 <= initial[i] <= n - 1
 * initial中所有整数均不重复
 * <p>
 * 来源：力扣（LeetCode）
 * 链接：<a href="https://leetcode.cn/problems/minimize-malware-spread/description/?envType=daily-question&envId=2024-04-16">...</a>
 * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
 */
public class L924_MinMalwareSpread {
    public static void main(String[] args) {
        L924_MinMalwareSpread l924MinMalwareSpread = new L924_MinMalwareSpread();
        System.out.println(l924MinMalwareSpread.minMalwareSpread(new int[][]{{1, 0, 1, 0}, {0, 1, 0, 1}, {1, 0, 1, 0}, {0, 1, 0, 1}}, new int[]{2, 1}));
    }

    public int minMalwareSpread(int[][] graph, int[] initial) {
        //分辨有多少个连通块
        boolean[] visit = new boolean[graph.length];
        boolean[] isInitial = new boolean[graph.length];
        for (int a : initial) {
            isInitial[a] = true;
        }
        Arrays.sort(initial);
        int ans = initial[0];
        int maxCnt = Integer.MIN_VALUE;
        for (int curNode : initial) {
            if (visit[curNode]) {
                continue;
            }
            int[] tempAns = {0, 0, Integer.MAX_VALUE};
            dfs(curNode, graph, visit, tempAns, isInitial);
            if (tempAns[1] == 1 && tempAns[0] > maxCnt) {
                maxCnt = tempAns[0];
                ans = tempAns[2];
            }
        }
        return ans;
    }

    private void dfs(int curNode, int[][] graph, boolean[] visit, int[] arr, boolean[] isInitial) {
        if (visit[curNode]) {
            return;
        }
        visit[curNode] = true;
        arr[0]++;
        if (isInitial[curNode]) {
            arr[1]++;
            arr[2] = Math.min(arr[2], curNode);
        }
        for (int i = 0; i < graph[curNode].length; i++) {
            if (graph[curNode][i] == 1) {
                dfs(i, graph, visit, arr, isInitial);
            }
        }
    }

}
